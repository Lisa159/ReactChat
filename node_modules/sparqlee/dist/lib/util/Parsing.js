"use strict";
// TODO: Find a library for this
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * TODO: Fix decently
 * Parses float datatypes (double, float).
 *
 * All invalid lexical values return undefined.
 *
 * @param value the string to interpret as a number
 */
function parseXSDFloat(value) {
    const numb = Number(value);
    if (isNaN(numb)) {
        if (value === 'NaN') {
            return NaN;
        }
        if (value === 'INF') {
            return Infinity;
        }
        if (value === '-INF') {
            return -Infinity;
        }
        return undefined;
    }
    return numb;
}
exports.parseXSDFloat = parseXSDFloat;
/**
 * Parses decimal datatypes (decimal, int, byte, nonPositiveInteger, etc...).
 *
 * All other values, including NaN, INF, and floating point numbers all
 * return undefined;
 *
 * @param value the string to interpret as a number
 */
function parseXSDDecimal(value) {
    if (/^(\-|\+)?([0-9]+(\.[0-9]+)?)$/.test(value)) {
        const numb = Number(value);
        return (isNaN(numb)) ? undefined : numb;
    }
    return undefined;
}
exports.parseXSDDecimal = parseXSDDecimal;
/**
 * Parses integer datatypes (decimal, int, byte, nonPositiveInteger, etc...).
 *
 * All other values, including NaN, INF, and floating point numbers all
 * return undefined;
 *
 * @param value the string to interpret as a number
 */
function parseXSDInteger(value) {
    if (/^(\-|\+)?([0-9]+)$/.test(value)) {
        const numb = Number(value);
        return (isNaN(numb)) ? undefined : numb;
    }
    return undefined;
}
exports.parseXSDInteger = parseXSDInteger;
//# sourceMappingURL=Parsing.js.map